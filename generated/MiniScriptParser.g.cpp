// AUTO-GENERATED FILE.  DO NOT MODIFY.
// Transpiled from: MiniScriptParser.cs

// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, John Gough, QUT 2005-2014
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.5.3
// DateTime: 11/15/2025 7:18:56 PM
// Input file <grammar/miniscript.y - 11/15/2025 7:14:43 PM>

// options: lines

#include "MiniScriptParser.g.h"

namespace MiniScript {

  Rule *Parser::rules = Rule[9];
  State *Parser::states = State[16];

  Parser::Parser() { InitStaticData(); }
  void Parser::InitStaticData() {
    if (initialized) return;
    initialized = true;
    states[0] = State({9,12,4,15},{-1,1,-3,3});
    states[1] = State({3,2});
    states[2] = State(-1);
    states[3] = State({5,4,6,6,7,8,8,10,3,-2});
    states[4] = State({9,12,4,15},{-3,5});
    states[5] = State({5,-3,6,-3,7,8,8,10,3,-3,10,-3});
    states[6] = State({9,12,4,15},{-3,7});
    states[7] = State({5,-4,6,-4,7,8,8,10,3,-4,10,-4});
    states[8] = State({9,12,4,15},{-3,9});
    states[9] = State(-5);
    states[10] = State({9,12,4,15},{-3,11});
    states[11] = State(-6);
    states[12] = State({9,12,4,15},{-3,13});
    states[13] = State({10,14,5,4,6,6,7,8,8,10});
    states[14] = State(-7);
    states[15] = State(-8);

    for (int sNo = 0; sNo < states.Length(); sNo++) states[sNo].number = sNo;

    rules[1] = Rule(-2, {-1,3});
    rules[2] = Rule(-1, {-3});
    rules[3] = Rule(-3, {-3,5,-3});
    rules[4] = Rule(-3, {-3,6,-3});
    rules[5] = Rule(-3, {-3,7,-3});
    rules[6] = Rule(-3, {-3,8,-3});
    rules[7] = Rule(-3, {9,-3,10});
    rules[8] = Rule(-3, {4});
  }

  void Parser::Initialize() {
    this->InitSpecialTokens((int)Tokens.error, (int)Tokens.END_OF_FILE);
    this->InitStates(states);
    this->InitRules(rules);
    this->InitNonTerminals(nonTerms);
  }

  void Parser::DoAction(int action) {
    switch (action) {
      case 2: // program -> expr
 { Console.WriteLine("Result: " + ValueStack[ValueStack.Depth-1]); }
        break;
      case 3: // expr -> expr, PLUS, expr
 { CurrentSemanticValue = ValueStack[ValueStack.Depth-3] + ValueStack[ValueStack.Depth-1]; }
        break;
      case 4: // expr -> expr, MINUS, expr
 { CurrentSemanticValue = ValueStack[ValueStack.Depth-3] - ValueStack[ValueStack.Depth-1]; }
        break;
      case 5: // expr -> expr, TIMES, expr
 { CurrentSemanticValue = ValueStack[ValueStack.Depth-3] * ValueStack[ValueStack.Depth-1]; }
        break;
      case 6: // expr -> expr, DIVIDE, expr
 { CurrentSemanticValue = ValueStack[ValueStack.Depth-3] / ValueStack[ValueStack.Depth-1]; }
        break;
      case 7: // expr -> LPAREN, expr, RPAREN
 { CurrentSemanticValue = ValueStack[ValueStack.Depth-2]; }
        break;
      case 8: // expr -> NUMBER
 { CurrentSemanticValue = ValueStack[ValueStack.Depth-1]; }
        break;
    }
  }

  String Parser::TerminalToString(int terminal) {
    if (aliases != nullptr && aliases.ContainsKey(terminal))
        return aliases[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }

}
