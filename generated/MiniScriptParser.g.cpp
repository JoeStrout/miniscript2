// Hand-converted MiniScript Parser from GPPG-generated C# code
// Original generated by Gardens Point Parser Generator

#include "MiniScriptParser.g.h"

namespace MiniScript {

// Static data initialization
QUT::Gppg::Rule* Parser::rules[9];
QUT::Gppg::State* Parser::states[16];
String Parser::nonTerms[3];
bool Parser::initialized = false;

void Parser::InitializeStaticData() {
	if (initialized) return;
	initialized = true;

	// Initialize states
	states[0] = new QUT::Gppg::State({9,12,4,15}, {-1,1,-3,3});
	states[1] = new QUT::Gppg::State({3,2});
	states[2] = new QUT::Gppg::State(-1);
	states[3] = new QUT::Gppg::State({5,4,6,6,7,8,8,10,3,-2});
	states[4] = new QUT::Gppg::State({9,12,4,15}, {-3,5});
	states[5] = new QUT::Gppg::State({5,-3,6,-3,7,8,8,10,3,-3,10,-3});
	states[6] = new QUT::Gppg::State({9,12,4,15}, {-3,7});
	states[7] = new QUT::Gppg::State({5,-4,6,-4,7,8,8,10,3,-4,10,-4});
	states[8] = new QUT::Gppg::State({9,12,4,15}, {-3,9});
	states[9] = new QUT::Gppg::State(-5);
	states[10] = new QUT::Gppg::State({9,12,4,15}, {-3,11});
	states[11] = new QUT::Gppg::State(-6);
	states[12] = new QUT::Gppg::State({9,12,4,15}, {-3,13});
	states[13] = new QUT::Gppg::State({10,14,5,4,6,6,7,8,8,10});
	states[14] = new QUT::Gppg::State(-7);
	states[15] = new QUT::Gppg::State(-8);

	// Set state numbers
	for (int sNo = 0; sNo < 16; sNo++) {
		states[sNo]->number = sNo;
	}

	// Initialize rules (allocated with new, never deleted - static lifetime)
	rules[1] = new QUT::Gppg::Rule(-2, {-1, 3});
	rules[2] = new QUT::Gppg::Rule(-1, {-3});
	rules[3] = new QUT::Gppg::Rule(-3, {-3, 5, -3});
	rules[4] = new QUT::Gppg::Rule(-3, {-3, 6, -3});
	rules[5] = new QUT::Gppg::Rule(-3, {-3, 7, -3});
	rules[6] = new QUT::Gppg::Rule(-3, {-3, 8, -3});
	rules[7] = new QUT::Gppg::Rule(-3, {9, -3, 10});
	rules[8] = new QUT::Gppg::Rule(-3, {4});

	// Initialize non-terminals
	nonTerms[0] = String("program");
	nonTerms[1] = String("$accept");
	nonTerms[2] = String("expr");
}

Parser::Parser() {
	InitializeStaticData();
}

Parser::~Parser() {
	// Note: states are static and shared, so don't delete them here
}

void Parser::Initialize() {
	this->InitSpecialTokens((int)Tokens::error, (int)Tokens::END_OF_FILE);
	this->InitStates(states, 16);
	this->InitRules(rules, 9);
	this->InitNonTerminals(nonTerms, 3);
}

void Parser::DoAction(int action) {
	switch (action) {
		case 2: // program -> expr
			{
				// Original C#: Console.WriteLine("Result: " + ValueStack[ValueStack.Depth-1]);
				std::cout << "Result: " << ValueStack()[ValueStack().Depth() - 1] << std::endl;
			}
			break;

		case 3: // expr -> expr, PLUS, expr
			CurrentSemanticValue = ValueStack()[ValueStack().Depth() - 3] + ValueStack()[ValueStack().Depth() - 1];
			break;

		case 4: // expr -> expr, MINUS, expr
			CurrentSemanticValue = ValueStack()[ValueStack().Depth() - 3] - ValueStack()[ValueStack().Depth() - 1];
			break;

		case 5: // expr -> expr, TIMES, expr
			CurrentSemanticValue = ValueStack()[ValueStack().Depth() - 3] * ValueStack()[ValueStack().Depth() - 1];
			break;

		case 6: // expr -> expr, DIVIDE, expr
			CurrentSemanticValue = ValueStack()[ValueStack().Depth() - 3] / ValueStack()[ValueStack().Depth() - 1];
			break;

		case 7: // expr -> LPAREN, expr, RPAREN
			CurrentSemanticValue = ValueStack()[ValueStack().Depth() - 2];
			break;

		case 8: // expr -> NUMBER
			CurrentSemanticValue = ValueStack()[ValueStack().Depth() - 1];
			break;
	}
}

String Parser::TerminalToString(int terminal) {
	switch ((Tokens)terminal) {
		case Tokens::error: return String("error");
		case Tokens::END_OF_FILE: return String("EOF");
		case Tokens::NUMBER: return String("NUMBER");
		case Tokens::PLUS: return String("PLUS");
		case Tokens::MINUS: return String("MINUS");
		case Tokens::TIMES: return String("TIMES");
		case Tokens::DIVIDE: return String("DIVIDE");
		case Tokens::LPAREN: return String("LPAREN");
		case Tokens::RPAREN: return String("RPAREN");
		default: return CharToString((char)terminal);
	}
}

} // namespace MiniScript
